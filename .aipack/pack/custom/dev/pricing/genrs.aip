# Options
```toml
model = "flash"
```

# Description

This assumes that `aip run dev@pricing` was run and created the `.ai-pricing/pricing-all.json` file.

Then, we can run this one as `aip run dev@pricing/genrs`.

# Data

```lua
local p_utils = require("pricing_utils")

local json_content = aip.file.load(p_utils.json_all_path).content

local data_rs = aip.file.load("src/run/pricing/data.rs")

return {
    json_content = json_content,
    data_rs      = data_rs,
}

```

# Instruction

Below is the JSON file that we need to translate into a Rust file and use to update the `data.rs` file, following its existing format.

```json
{{data.json_content}}
```

Here is the `data.rs` file to update:

```rs
{{data.data_rs.content}}
```

Importantly, we must keep the `data.rs` types as they are, updating or adding only the necessary values. Also, keep the whitespace.

Here are some crucial rules for updating `data.rs`:

- For OpenAI models, when the name is prefixed with `openai-`, you can remove the prefix from the model name.
- For Gemini models, ignore the "preview" suffix (for example, `gemini-2.5-pro-preview` becomes `gemini-2.5-pro`).
- For Gemini pricing, make sure the cache price is defined.
- For the Google provider, ignore `gemma-3-27b-it` and `text-embedding-004`.
- Only make necessary changes.
- For OpenAI pricing, ignore the "flex..." models.
- For OpenAI pricing, ignore the audio models.
- Do not remove existing entries that are present in the JSON.
- Do not add any comments. Comments are not needed in this file.
- Do not remove comments, and do not add comments.

Just return the `data.rs` file content in a Rust markdown code block.

Also, importantly, do not use code comments to explain what you did. Code comments should be used to document the code, not to explain why a specific update was made.

# Output

```lua
local content = ai_response.content
content = aip.md.outer_block_content_or_raw(content)

aip.file.save("src/run/pricing/data.rs", content)

return "Data saved to src/pricing/data.rs"

```